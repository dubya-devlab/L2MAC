[{"choices": [{"message": {"role": "assistant", "function_call": {"name": "provide_detailed_sub_task_steps_for_sub_agents", "arguments": "{\n  \"steps\": [\n    \"Step 1: Start by setting up the project structure. Create a new directory for the project and initialize it as a Python project. Create a virtual environment and activate it. Create the main directories and files that will be needed for the project. These include the 'app' directory for the application code, 'tests' directory for the test code, 'requirements.txt' for the project dependencies, and 'main.py' as the entry point of the application. Write the initial code in 'main.py' to set up a Flask application and run it.\",\n    \n    \"Step 2: Set up the user registration and authentication system. Create a new file 'auth.py' in the 'app' directory. In this file, define a User dataclass with fields for id, email, password, and other necessary information. Also, define functions for user registration and login. The registration function should take an email and password, create a new User instance, and store it in an in-memory dictionary. The login function should take an email and password, check if a User with the given email and password exists in the dictionary, and return the User instance if it does. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 3: Implement the forgotten password recovery feature. In 'auth.py', define a function for password recovery. This function should take an email, generate a temporary password, set it as the new password for the User with the given email, and return the temporary password. Write tests for this function and run them to ensure it works correctly.\",\n    \n    \"Step 4: Set up the user profile system. Create a new file 'profile.py' in the 'app' directory. In this file, define a Profile dataclass with fields for user id, profile picture, status message, and privacy settings. Also, define functions for setting a profile picture, setting a status message, and changing privacy settings. Each of these functions should take a user id and the new value, update the corresponding field in the Profile instance associated with the user id, and return the updated Profile instance. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 5: Implement the contact management system. Create a new file 'contacts.py' in the 'app' directory. In this file, define a Contact dataclass with fields for user id, contact id, and blocked status. Also, define functions for blocking and unblocking contacts. Each of these functions should take a user id and a contact id, update the blocked status in the Contact instance associated with the user id and contact id, and return the updated Contact instance. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 6: Implement the group management system. In 'contacts.py', define a Group dataclass with fields for id, name, picture, and list of participant ids. Also, define functions for creating a group, adding a participant to a group, and removing a participant from a group. Each of these functions should update the corresponding Group instance and return it. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 7: Set up the messaging system. Create a new file 'messaging.py' in the 'app' directory. In this file, define a Message dataclass with fields for id, sender id, receiver id, text, read status, and timestamp. Also, define functions for sending a message, receiving a message, and updating the read status of a message. Each of these functions should update the corresponding Message instance and return it. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 8: Implement the end-to-end encryption feature. In 'messaging.py', define a function for encrypting a message. This function should take a message text and a key, encrypt the text using the key, and return the encrypted text. Also, define a function for decrypting a message. This function should take an encrypted text and a key, decrypt the text using the key, and return the decrypted text. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 9: Implement the image sharing feature. In 'messaging.py', define a function for sending an image. This function should take a sender id, receiver id, and image data, create a new Message instance with the image data, and return the Message instance. Write tests for this function and run them to ensure it works correctly.\",\n    \n    \"Step 10: Implement the emojis, GIFs, and stickers support feature. In 'messaging.py', define a function for sending an emoji, GIF, or sticker. This function should take a sender id, receiver id, and emoji, GIF, or sticker data, create a new Message instance with the data, and return the Message instance. Write tests for this function and run them to ensure it works correctly.\",\n    \n    \"Step 11: Implement the group chats feature. In 'messaging.py', define a function for sending a message to a group. This function should take a sender id, group id, and message text, create a new Message instance for each participant in the group, and return the list of Message instances. Write tests for this function and run them to ensure it works correctly.\",\n    \n    \"Step 12: Implement the admin roles and permissions feature. In 'contacts.py', add fields for admin ids and permissions to the Group dataclass. Also, define functions for adding an admin to a group, removing an admin from a group, and changing the permissions of an admin. Each of these functions should update the corresponding Group instance and return it. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 13: Set up the status/story feature. Create a new file 'status.py' in the 'app' directory. In this file, define a Status dataclass with fields for user id, image, visibility, and timestamp. Also, define functions for posting a status, viewing a status, and deleting a status. Each of these functions should update the corresponding Status instance and return it. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 14: Implement the web application feature. Create a new directory 'templates' in the 'app' directory. In this directory, create HTML templates for the different pages of the application, such as the login page, registration page, chat page, and profile page. In 'main.py', set up routes for these pages and render the corresponding templates. Write tests for these routes and run them to ensure they work correctly.\",\n    \n    \"Step 15: Implement the connectivity and offline mode feature. In 'messaging.py', add a field for online status to the User dataclass. Also, define a function for updating the online status of a user. This function should take a user id and a new status, update the online status in the User instance associated with the user id, and return the updated User instance. Write tests for this function and run them to ensure it works correctly.\",\n    \n    \"Step 16: Implement the message queuing feature. In 'messaging.py', define a function for queuing a message. This function should take a Message instance, check if the receiver is offline, and if so, add the message to a queue associated with the receiver id. Also, define a function for sending queued messages. This function should take a user id, check if the user is online, and if so, send all messages in the queue associated with the user id. Write tests for these functions and run them to ensure they work correctly.\",\n    \n    \"Step 17: Finally, integrate all the components of the application. In 'main.py', import all the modules and set up routes for all the functions. Also, set up error handling and logging. Run the application and manually test all the features to ensure they work correctly.\"\n  ]\n}"}, "content": null}}]}, {"choices": [{"message": {}}]}]