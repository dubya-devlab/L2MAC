[{"id": "chatcmpl-8K0ZijmPxZRCXzIsDqNcqVLY1A5hc", "object": "chat.completion", "created": 1699779462, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "function_call": {"name": "write_files", "arguments": "{\n  \"files_and_contents\": [\n    {\n      \"file_path\": \"requirements.txt\",\n      \"file_contents\": \"flask\\npytest\\ndataclasses\"\n    },\n    {\n      \"file_path\": \"app.py\",\n      \"file_contents\": \"from flask import Flask, request, redirect\\nfrom dataclasses import dataclass\\nimport datetime\\nimport random\\nimport string\\n\\napp = Flask(__name__)\\n\\n# Mock database\\nDB = {}\\n\\n@dataclass\\nclass URL:\\n\\toriginal: str\\n\\tshort: str\\n\\tclicks: int\\n\\tcreated_at: datetime.datetime\\n\\texpires_at: datetime.datetime\\n\\tuser_id: str\\n\\n@app.route('/shorten', methods=['POST'])\\ndef shorten_url():\\n\\tdata = request.get_json()\\n\\toriginal_url = data.get('url')\\n\\tuser_id = data.get('user_id')\\n\\tshort_url = ''.join(random.choices(string.ascii_uppercase + string.digits, k=5))\\n\\turl = URL(original_url, short_url, 0, datetime.datetime.now(), None, user_id)\\n\\tDB[short_url] = url\\n\\treturn {'short_url': short_url}\\n\\n@app.route('/<short_url>', methods=['GET'])\\ndef redirect_to_url(short_url):\\n\\turl = DB.get(short_url)\\n\\tif url and (not url.expires_at or url.expires_at > datetime.datetime.now()):\\n\\t\\turl.clicks += 1\\n\\t\\treturn redirect(url.original, code=302)\\n\\telse:\\n\\t\\treturn {'error': 'URL not found or expired'}, 404\"\n    },\n    {\n      \"file_path\": \"test_app.py\",\n      \"file_contents\": \"import pytest\\nimport app\\nimport datetime\\n\\n@pytest.fixture\\ndef client():\\n\\tapp.app.config['TESTING'] = True\\n\\twith app.app.test_client() as client:\\n\\t\\tyield client\\n\\n@pytest.fixture\\ndef url():\\n\\treturn app.URL('http://example.com', 'ABCDE', 0, datetime.datetime.now(), None, 'user1')\\n\\ndef test_shorten_url(client, url):\\n\\tresponse = client.post('/shorten', json={'url': url.original, 'user_id': url.user_id})\\n\\tassert response.status_code == 200\\n\\tassert 'short_url' in response.get_json()\\n\\ndef test_redirect_to_url(client, url):\\n\\tapp.DB[url.short] = url\\n\\tresponse = client.get(f'/{url.short}')\\n\\tassert response.status_code == 302\\n\\tassert response.location == url.original\\n\\tassert app.DB[url.short].clicks == 1\\n\\n\\t# Test expired URL\\n\\turl.expires_at = datetime.datetime.now() - datetime.timedelta(days=1)\\n\\tresponse = client.get(f'/{url.short}')\\n\\tassert response.status_code == 404\"\n    }\n  ]\n}"}, "content": null}, "content_filter_results": {}}], "usage": {"prompt_tokens": 1393, "completion_tokens": 621, "total_tokens": 2014}}, {"id": "chatcmpl-8K0aAqzWgeR3rfISqhhE2JTBX4NGf", "object": "chat.completion", "created": 1699779490, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "1"}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "usage": {"prompt_tokens": 1017, "completion_tokens": 1, "total_tokens": 1018}}, {"id": "chatcmpl-8K0aAjsC2Xuu5meeeZm1L7slpt8aJ", "object": "chat.completion", "created": 1699779490, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "The generated code successfully implements a URL shortening service with Flask, but it does not fully meet the original specifications. The code lacks the feature to allow users to specify a custom short URL and does not implement the feature to allow users to specify an expiration date for the short URL. \n\nTo mitigate this, the new plan would be to modify the 'shorten_url' function in the 'app.py' file to accept optional parameters for a custom short URL and an expiration date. If these parameters are provided in the request, they should be used when creating the URL object. If a custom short URL is provided, the function should check if it already exists in the database and return an error if it does. If an expiration date is provided, it should be converted to a datetime object and stored in the URL object. The 'redirect_to_url' function should also be updated to check the expiration date of the URL before redirecting. The test cases in the 'test_app.py' file should also be updated to test these new features."}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "usage": {"prompt_tokens": 1193, "completion_tokens": 208, "total_tokens": 1401}}, {"id": "chatcmpl-8K0aIuZNxwvR89RXEpVlZQ8zmTEVv", "object": "chat.completion", "created": 1699779498, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "function_call": {"name": "write_files", "arguments": "{\n  \"files_and_contents\": [\n    {\n      \"file_path\": \"app.py\",\n      \"file_contents\": \"from flask import Flask, request, redirect, jsonify\\nfrom dataclasses import dataclass\\nfrom datetime import datetime\\nimport requests\\n\\napp = Flask(__name__)\\n\\n# Mock database\\nurls_db = {}\\n\\n@dataclass\\nclass URL:\\n\\toriginal_url: str\\n\\tshort_url: str\\n\\texpiration_date: datetime = None\\n\\n@app.route('/shorten_url', methods=['POST'])\\ndef shorten_url():\\n\\tdata = request.get_json()\\n\\toriginal_url = data.get('original_url')\\n\\tcustom_short_url = data.get('custom_short_url')\\n\\texpiration_date = data.get('expiration_date')\\n\\n\\t# Validate original URL\\n\\ttry:\\n\\t\\tresponse = requests.get(original_url)\\n\\t\\tresponse.raise_for_status()\\n\\texcept (requests.RequestException, ValueError):\\n\\t\\treturn jsonify({'error': 'Invalid URL'}), 400\\n\\n\\t# Check if custom short URL already exists\\n\\tif custom_short_url and custom_short_url in urls_db:\\n\\t\\treturn jsonify({'error': 'Custom short URL already exists'}), 400\\n\\n\\t# Generate short URL\\n\\tshort_url = custom_short_url or str(len(urls_db) + 1)\\n\\n\\t# Convert expiration date to datetime object\\n\\tif expiration_date:\\n\\t\\texpiration_date = datetime.strptime(expiration_date, '%Y-%m-%d %H:%M:%S')\\n\\n\\t# Create URL object and store in database\\n\\turl = URL(original_url, short_url, expiration_date)\\n\\turls_db[short_url] = url\\n\\n\\treturn jsonify({'short_url': short_url}), 201\\n\\n@app.route('/<short_url>', methods=['GET'])\\ndef redirect_to_url(short_url):\\n\\turl = urls_db.get(short_url)\\n\\n\\t# Check if URL exists\\n\\tif not url:\\n\\t\\treturn jsonify({'error': 'URL not found'}), 404\\n\\n\\t# Check if URL has expired\\n\\tif url.expiration_date and url.expiration_date < datetime.now():\\n\\t\\treturn jsonify({'error': 'URL has expired'}), 410\\n\\n\\t# Redirect to original URL\\n\\treturn redirect(url.original_url, code=302)\\n\\nif __name__ == '__main__':\\n\\tapp.run(debug=True)\"\n    },\n    {\n      \"file_path\": \"test_app.py\",\n      \"file_contents\": \"import pytest\\nfrom app import app, urls_db, URL\\nfrom datetime import datetime, timedelta\\n\\n@pytest.fixture\\ndef client():\\n\\tapp.config['TESTING'] = True\\n\\twith app.test_client() as client:\\n\\t\\tyield client\\n\\n\\t# Clear database after each test\\n\\turls_db.clear()\\n\\n\\ndef test_shorten_url(client):\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.google.com'})\\n\\tassert response.status_code == 201\\n\\tassert 'short_url' in response.get_json()\\n\\n\\t# Test with custom short URL\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.example.com', 'custom_short_url': 'example'})\\n\\tassert response.status_code == 201\\n\\tassert response.get_json()['short_url'] == 'example'\\n\\n\\t# Test with existing custom short URL\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.test.com', 'custom_short_url': 'example'})\\n\\tassert response.status_code == 400\\n\\tassert 'error' in response.get_json()\\n\\n\\t# Test with expiration date\\n\\texpiration_date = (datetime.now() + timedelta(minutes=1)).strftime('%Y-%m-%d %H:%M:%S')\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.expire.com', 'expiration_date': expiration_date})\\n\\tassert response.status_code == 201\\n\\tassert 'short_url' in response.get_json()\\n\\n\\ndef test_redirect_to_url(client):\\n\\turls_db['1'] = URL('https://www.google.com', '1')\\n\\tresponse = client.get('/1')\\n\\tassert response.status_code == 302\\n\\tassert response.location == 'https://www.google.com'\\n\\n\\t# Test with non-existent URL\\n\\tresponse = client.get('/2')\\n\\tassert response.status_code == 404\\n\\tassert 'error' in response.get_json()\\n\\n\\t# Test with expired URL\\n\\turls_db['expire'] = URL('https://www.expire.com', 'expire', datetime.now() - timedelta(minutes=1))\\n\\tresponse = client.get('/expire')\\n\\tassert response.status_code == 410\\n\\tassert 'error' in response.get_json()\"\n    }\n  ]\n}"}, "content": null}, "content_filter_results": {}}], "usage": {"prompt_tokens": 1601, "completion_tokens": 1054, "total_tokens": 2655}}, {"id": "chatcmpl-8K0buRXN5v8VwZzDZBksg2hhouCEQ", "object": "chat.completion", "created": 1699779598, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "7"}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "usage": {"prompt_tokens": 2773, "completion_tokens": 1, "total_tokens": 2774}}, {"id": "chatcmpl-8K0bv8H4A11U9Z7T4CBdQ8Lfr0zpo", "object": "chat.completion", "created": 1699779599, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "The generated code successfully implements a URL shortening service with Flask, but it does not fully meet the original specifications. The code lacks the feature to allow users to specify a custom short URL and does not implement the feature to allow users to specify an expiration date for the short URL. \n\nTo mitigate this, the new plan would be to modify the 'shorten_url' function in the 'app.py' file to accept optional parameters for a custom short URL and an expiration date. If these parameters are provided in the request, they should be used when creating the URL object. If a custom short URL is provided, the function should check if it already exists in the database and return an error if it does. If an expiration date is provided, it should be converted to a datetime object and stored in the URL object. The 'redirect_to_url' function should also be updated to check the expiration date of the URL before redirecting. The test cases in the 'test_app.py' file should also be updated to test these new features."}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "usage": {"prompt_tokens": 2949, "completion_tokens": 208, "total_tokens": 3157}}, {"id": "chatcmpl-8K0c1jWrQ5Wcc8K6lJDtU8qZJ1xQs", "object": "chat.completion", "created": 1699779605, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "function_call": {"name": "write_files", "arguments": "{\n  \"files_and_contents\": [\n    {\n      \"file_path\": \"app.py\",\n      \"file_contents\": \"from flask import Flask, request, redirect, jsonify\\nfrom dataclasses import dataclass\\nfrom datetime import datetime, timedelta\\nimport requests\\nimport string\\nimport random\\n\\napp = Flask(__name__)\\n\\n# Mock database\\nDB = {}\\n\\n@dataclass\\nclass URL:\\n\\toriginal: str\\n\\tshort: str\\n\\texpiration: datetime = None\\n\\n@app.route('/shorten_url', methods=['POST'])\\ndef shorten_url():\\n\\tdata = request.get_json()\\n\\toriginal_url = data.get('original_url')\\n\\tcustom_short_url = data.get('custom_short_url')\\n\\texpiration_date = data.get('expiration_date')\\n\\n\\t# Validate original URL\\n\\ttry:\\n\\t\\tresponse = requests.get(original_url)\\n\\t\\tresponse.raise_for_status()\\n\\texcept (requests.RequestException, ValueError):\\n\\t\\treturn jsonify({'error': 'Invalid URL'}), 400\\n\\n\\t# Generate short URL\\n\\tif custom_short_url:\\n\\t\\t# Check if custom short URL already exists\\n\\t\\tif custom_short_url in DB:\\n\\t\\t\\treturn jsonify({'error': 'Custom short URL already exists'}), 400\\n\\t\\tshort_url = custom_short_url\\n\\telse:\\n\\t\\tshort_url = ''.join(random.choices(string.ascii_letters + string.digits, k=6))\\n\\n\\t# Convert expiration date to datetime object\\n\\tif expiration_date:\\n\\t\\ttry:\\n\\t\\t\\texpiration_date = datetime.strptime(expiration_date, '%Y-%m-%d %H:%M:%S')\\n\\t\\texcept ValueError:\\n\\t\\t\\treturn jsonify({'error': 'Invalid expiration date format'}), 400\\n\\n\\t# Create URL object and store in database\\n\\tDB[short_url] = URL(original_url, short_url, expiration_date)\\n\\n\\treturn jsonify({'short_url': short_url}), 201\\n\\n@app.route('/<short_url>', methods=['GET'])\\ndef redirect_to_url(short_url):\\n\\t# Check if short URL exists\\n\\turl = DB.get(short_url)\\n\\tif not url:\\n\\t\\treturn jsonify({'error': 'Short URL not found'}), 404\\n\\n\\t# Check if URL has expired\\n\\tif url.expiration and url.expiration < datetime.now():\\n\\t\\treturn jsonify({'error': 'URL has expired'}), 410\\n\\n\\t# Redirect to original URL\\n\\treturn redirect(url.original), 302\"\n    },\n    {\n      \"file_path\": \"test_app.py\",\n      \"file_contents\": \"import pytest\\nfrom app import app, DB, URL\\nfrom datetime import datetime, timedelta\\n\\n@pytest.fixture\\ndef client():\\n\\tapp.config['TESTING'] = True\\n\\twith app.test_client() as client:\\n\\t\\tyield client\\n\\n\\t# Clear database after each test\\n\\tDB.clear()\\n\\ndef test_shorten_url(client):\\n\\t# Test shortening URL\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.google.com'})\\n\\tassert response.status_code == 201\\n\\tshort_url = response.get_json()['short_url']\\n\\tassert DB[short_url].original == 'https://www.google.com'\\n\\n\\t# Test shortening URL with custom short URL\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.google.com', 'custom_short_url': 'google'})\\n\\tassert response.status_code == 201\\n\\tassert DB['google'].original == 'https://www.google.com'\\n\\n\\t# Test shortening URL with expiration date\\n\\texpiration_date = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d %H:%M:%S')\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.google.com', 'expiration_date': expiration_date})\\n\\tassert response.status_code == 201\\n\\tshort_url = response.get_json()['short_url']\\n\\tassert DB[short_url].expiration == datetime.strptime(expiration_date, '%Y-%m-%d %H:%M:%S')\\n\\n\\t# Test shortening URL with invalid URL\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'invalid'})\\n\\tassert response.status_code == 400\\n\\n\\t# Test shortening URL with existing custom short URL\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.google.com', 'custom_short_url': 'google'})\\n\\tassert response.status_code == 400\\n\\n\\t# Test shortening URL with invalid expiration date format\\n\\tresponse = client.post('/shorten_url', json={'original_url': 'https://www.google.com', 'expiration_date': 'invalid'})\\n\\tassert response.status_code == 400\\n\\ndef test_redirect_to_url(client):\\n\\t# Test redirecting to original URL\\n\\tDB['google'] = URL('https://www.google.com', 'google')\\n\\tresponse = client.get('/google')\\n\\tassert response.status_code == 302\\n\\tassert response.location == 'https://www.google.com'\\n\\n\\t# Test redirecting to non-existent short URL\\n\\tresponse = client.get('/nonexistent')\\n\\tassert response.status_code == 404\\n\\n\\t# Test redirecting to expired URL\\n\\tDB['expired'] = URL('https://www.google.com', 'expired', datetime.now() - timedelta(days=1))\\n\\tresponse = client.get('/expired')\\n\\tassert response.status_code == 410\"\n    }\n  ]\n}"}, "content": null}, "content_filter_results": {}}], "usage": {"prompt_tokens": 1601, "completion_tokens": 1216, "total_tokens": 2817}}, {"id": "chatcmpl-8K0cxFToXaGUtwfldmikhJXrTWd10", "object": "chat.completion", "created": 1699779663, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "6"}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "usage": {"prompt_tokens": 2869, "completion_tokens": 1, "total_tokens": 2870}}, {"id": "chatcmpl-8K0cytFQFdffA1YrccFqfBtWq3qMo", "object": "chat.completion", "created": 1699779664, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "content": "The generated code successfully implements a URL shortening service with Flask, but it does not fully meet the original specifications. The code lacks the feature to allow users to specify a custom short URL and does not implement the feature to allow users to specify an expiration date for the short URL. \n\nTo mitigate this, the new plan would be to modify the 'shorten_url' function in the 'app.py' file to accept optional parameters for a custom short URL and an expiration date. If these parameters are provided in the request, they should be used when creating the URL object. If a custom short URL is provided, the function should check if it already exists in the database and return an error if it does. If an expiration date is provided, it should be converted to a datetime object and stored in the URL object. The 'redirect_to_url' function should also be updated to check the expiration date of the URL before redirecting. The test cases in the 'test_app.py' file should also be updated to test these new features."}, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "usage": {"prompt_tokens": 3045, "completion_tokens": 208, "total_tokens": 3253}}, {"id": "chatcmpl-8K0d7MPBpdLHwPGwaSymhSai190dn", "object": "chat.completion", "created": 1699779673, "model": "gpt-4", "prompt_filter_results": [{"prompt_index": 0, "content_filter_results": {"hate": {"filtered": false, "severity": "safe"}, "self_harm": {"filtered": false, "severity": "safe"}, "sexual": {"filtered": false, "severity": "safe"}, "violence": {"filtered": false, "severity": "safe"}}}], "choices": [{"index": 0, "finish_reason": "stop", "message": {"role": "assistant", "function_call": {"name": "write_files", "arguments": "\n{\n  \"files_and_contents\": [\n    {\n      \"file_path\": \"app.py\",\n      \"file_contents\": \"from flask import Flask, request, redirect, jsonify\\nfrom dataclasses import dataclass\\nfrom datetime import datetime, timedelta\\nimport random\\nimport string\\n\\napp = Flask(__name__)\\n\\n# Mock database\\nurls_db = {}\\n\\n@dataclass\\nclass URL:\\n\\toriginal_url: str\\n\\tshort_url: str\\n\\texpiration_date: datetime = None\\n\\n@app.route('/shorten_url', methods=['POST'])\\ndef shorten_url():\\n\\tdata = request.get_json()\\n\\toriginal_url = data.get('original_url')\\n\\tcustom_short_url = data.get('custom_short_url')\\n\\texpiration_date = data.get('expiration_date')\\n\\n\\tif custom_short_url and custom_short_url in urls_db:\\n\\t\\treturn jsonify({'error': 'Custom short URL already exists'}), 400\\n\\n\\tshort_url = custom_short_url or ''.join(random.choices(string.ascii_letters + string.digits, k=5))\\n\\turls_db[short_url] = URL(original_url, short_url, datetime.strptime(expiration_date, '%Y-%m-%d %H:%M:%S') if expiration_date else None)\\n\\n\\treturn jsonify({'short_url': short_url}), 200\\n\\n@app.route('/<short_url>', methods=['GET'])\\ndef redirect_to_url(short_url):\\n\\turl = urls_db.get(short_url)\\n\\n\\tif not url:\\n\\t\\treturn jsonify({'error': 'URL not found'}), 404\\n\\n\\tif url.expiration_date and url.expiration_date < datetime.now():\\n\\t\\treturn jsonify({'error': 'URL expired'}), 410\\n\\n\\treturn redirect(url.original_url, code=302)\\n\\nif __name__ == '__main__':\\n\\tapp.run(debug=True)\"\n    },\n    {\n      \"file_path\": \"test_app.py\",\n      \"file_contents\": \"import pytest\\nfrom app import app, urls_db, URL\\nfrom datetime import datetime, timedelta\\n\\n@pytest.fixture\\ndef client():\\n\\tapp.config['TESTING'] = True\\n\\twith app.test_client() as client:\\n\\t\\tyield client\\n\\n@pytest.fixture(autouse=True)\\ndef clear_db():\\n\\turls_db.clear()\\n\\n@pytest.mark.parametrize('original_url, custom_short_url, expiration_date', [\\n\\t('https://www.google.com', None, None),\\n\\t('https://www.google.com', 'custom', None),\\n\\t('https://www.google.com', None, (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d %H:%M:%S')),\\n])\\ndef test_shorten_url(client, original_url, custom_short_url, expiration_date):\\n\\tresponse = client.post('/shorten_url', json={'original_url': original_url, 'custom_short_url': custom_short_url, 'expiration_date': expiration_date})\\n\\tassert response.status_code == 200\\n\\tassert 'short_url' in response.get_json()\\n\\n\\tshort_url = response.get_json()['short_url']\\n\\tassert urls_db[short_url].original_url == original_url\\n\\tassert urls_db[short_url].short_url == short_url\\n\\tassert urls_db[short_url].expiration_date == datetime.strptime(expiration_date, '%Y-%m-%d %H:%M:%S') if expiration_date else None\\n\\n\\tresponse = client.get(f'/{short_url}')\\n\\tassert response.status_code == 302\\n\\tassert response.location == original_url\\n\\n\\tif expiration_date:\\n\\t\\turls_db[short_url].expiration_date = datetime.now() - timedelta(minutes=1)\\n\\t\\tresponse = client.get(f'/{short_url}')\\n\\t\\tassert response.status_code == 410\\n\\n\\tresponse = client.post('/shorten_url', json={'original_url': original_url, 'custom_short_url': short_url})\\n\\tassert response.status_code == 400\\n\\tassert 'error' in response.get_json()\\n\\tassert response.get_json()['error'] == 'Custom short URL already exists'\"\n    }\n  ]\n}"}}, "content_filter_results": {}}], "usage": {"prompt_tokens": 1601, "completion_tokens": 889, "total_tokens": 2490}}]